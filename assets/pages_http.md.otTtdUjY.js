import{_ as i,c as a,ao as e,o as t}from"./chunks/framework.BbYUXk_8.js";const o="/handbook/assets/httpcache.Doel8ZcA.png",k=JSON.parse('{"title":"http","description":"","frontmatter":{},"headers":[],"relativePath":"pages/http.md","filePath":"pages/http.md","lastUpdated":1708654858000}'),s={name:"pages/http.md"};function h(p,l,c,d,r,n){return t(),a("div",null,l[0]||(l[0]=[e('<h1 id="http" tabindex="-1">http <a class="header-anchor" href="#http" aria-label="Permalink to &quot;http&quot;">​</a></h1><h2 id="http-协议特点" tabindex="-1">http 协议特点 <a class="header-anchor" href="#http-协议特点" aria-label="Permalink to &quot;http 协议特点&quot;">​</a></h2><ul><li>1、<code>简单快速</code>：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有 GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。</li><li>2、<code>灵活</code>：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。</li><li>3.<code>无连接</code>：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li><li>4.<code>无状态</code>：HTTP 协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li><li>5、支持<code>B/S及C/S</code>模式。</li></ul><h2 id="http-报文的组成部分" tabindex="-1">http 报文的组成部分 <a class="header-anchor" href="#http-报文的组成部分" aria-label="Permalink to &quot;http 报文的组成部分&quot;">​</a></h2><ul><li><p>第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的 HTTP 版本.</p><blockquote><p>GET 说明请求类型为 GET,[/hu.jpg]为要访问的资源，该行的最后一部分说明使用的是 HTTP1.1 版本。</p></blockquote></li><li><p>第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息</p><blockquote><p>从第二行起为请求头部，HOST 将指出请求的目的地.User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等</p></blockquote></li><li><p>第三部分：空行，请求头部后面的空行是必须的</p><blockquote><p>即使第四部分的请求数据为空，也必须有空行。</p></blockquote></li><li><p>第四部分：请求数据也叫主体，可以添加任意的其他数据。</p><blockquote><p>这个例子的请求数据为空。</p></blockquote></li></ul><h2 id="http-之状态码" tabindex="-1">HTTP 之状态码 <a class="header-anchor" href="#http-之状态码" aria-label="Permalink to &quot;HTTP 之状态码&quot;">​</a></h2><ul><li>1xx：指示信息--表示请求已接收，继续处理</li><li>2xx：成功--表示请求已被成功接收、理解、接受</li><li>3xx：重定向--要完成请求必须进行更进一步的操作</li><li>4xx：客户端错误--请求有语法错误或请求无法实现</li><li>5xx：服务器端错误--服务器未能实现合法的请求</li></ul><h2 id="常见状态码" tabindex="-1">常见状态码： <a class="header-anchor" href="#常见状态码" aria-label="Permalink to &quot;常见状态码：&quot;">​</a></h2><ul><li>200 OK <code>客户端请求成功</code></li><li>400 Bad Request <code>客户端请求有语法错误，不能被服务器所理解</code></li><li>401 Unauthorized <code>请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用</code></li><li>403 Forbidden <code>服务器收到请求，但是拒绝提供服务</code></li><li>404 Not Found <code>请求资源不存在，eg：输入了错误的URL</code></li><li>500 Internal Server Error <code>服务器发生不可预期的错误</code></li><li>503 Server Unavailable <code>服务器当前不能处理客户端的请求，一段时间后可能恢复正常</code></li><li>201: 已创建</li><li>202: 已接受</li><li>203: 成为，但未授权</li><li>204: 成功，无内容</li><li>205: 成功，重置内容</li><li>206: 成功，部分内容 <code>断点续传</code></li><li>301: 永久移动，重定向</li><li>302: 临时移动，可使用原有 URI</li><li>304: 资源未修改，可使用缓存</li><li>305: 需代理访问</li></ul><h2 id="get、post-区别" tabindex="-1">GET、POST 区别 <a class="header-anchor" href="#get、post-区别" aria-label="Permalink to &quot;GET、POST 区别&quot;">​</a></h2><ul><li>GET 请求会被浏览器主动缓存，POST 不会，除非手动设置</li><li>GET 请求参数在 URL 中是会限制的，POST 没有限制</li><li>GET 请求参数在 URL 中，POST 放在 request body 中</li></ul><h2 id="什么是长连接、短连接" tabindex="-1">什么是长连接、短连接 <a class="header-anchor" href="#什么是长连接、短连接" aria-label="Permalink to &quot;什么是长连接、短连接&quot;">​</a></h2><ul><li>在 HTTP/1.0 中默认使用短连接。也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源（如 JavaScript 文件、图像文件、CSS 文件等），每遇到这样一个 Web 资源，浏览器就会重新建立一个 HTTP 会话。</li><li>而从 HTTP/1.1 起，默认使用长连接，用以保持连接特性。使用长连接的 HTTP 协议，会在响应头加入这行代码：<code>Connection:keep-alive</code></li><li>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如 Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</li><li>HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。</li></ul><h2 id="http-缓存架构图" tabindex="-1">http 缓存架构图 <a class="header-anchor" href="#http-缓存架构图" aria-label="Permalink to &quot;http 缓存架构图&quot;">​</a></h2><p><img src="'+o+`" alt="httpcache"></p><h2 id="last-modified-etag" tabindex="-1">Last-Modified &amp; Etag <a class="header-anchor" href="#last-modified-etag" aria-label="Permalink to &quot;Last-Modified &amp; Etag&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><ul><li>Last-Modified 文件最后修改的时候</li><li>ETag 的值服务端是对文件的索引节，大小和最后修改时间进行 Hash 后得到的</li></ul></div><ul><li><p>有了 Last-Modified，为什么还要用 ETag？</p><blockquote><p>（1）因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified 可能就会不正确。</p></blockquote><blockquote><p>（2）某些服务器不能精确的得到文件的最后修改时间。</p></blockquote><blockquote><p>（3）一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新 GET。</p></blockquote></li><li><p>有了 Etag，为什么还要用 Last-Modified ?</p><blockquote><p>因为有些时候 ETag 可以弥补 Last-Modified 判断的缺陷，但是也有时候 Last-Modified 可以弥补 ETag 判断的缺陷，比如一些图片等静态文件的修改，如果每次扫描内容生成 ETag 来比较，显然要比直接比较修改时间慢很多。所有说这两种判断是相辅相成的。</p></blockquote></li></ul><h2 id="强缓存-协商缓存" tabindex="-1">强缓存 &amp; 协商缓存 <a class="header-anchor" href="#强缓存-协商缓存" aria-label="Permalink to &quot;强缓存 &amp; 协商缓存&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>强缓存时间未过期不会主动向服务器发请求 Cache-Control/Expires: 浏览器判断缓存是否过期，未过期时，直接使用强缓存，Cache-Control 的 max-age 优先级高于 Expires Etag 的优先级高于 Last-Modified</p></div><ul><li><p>强缓存</p><blockquote><p>cache-control</p></blockquote><blockquote><p>max-age 浏览器缓存时间，时间未过期直接读取浏览器缓存</p></blockquote><blockquote><p>s-max-age CND 缓存时间 s-max-age 大于 max-age，所有先读取 CND</p></blockquote><blockquote><p>private 私有的缓存一般存在浏览器</p></blockquote><blockquote><p>public 公共的缓存一般存在 CND 服务器</p></blockquote><blockquote><p>no-store 禁用缓存</p></blockquote><blockquote><p>expires 缓存过期时间 max-age 大于 expires，所有先看 max-age</p></blockquote></li><li><p>协商缓存</p><blockquote><p>Last-Modified 服务器资源最后一次修改的时间 存在 response</p></blockquote><blockquote><p>If-Modified-Since 服务器资源最后一次修改的时间 存在 requset 浏览器请求的时候会带上 if-modified-since 时间，服务器经过对比时间相同返回 304 读取浏览器缓存，不同返回 200 重新请求资源</p></blockquote><blockquote><p>Etag-None-Match response requset 都会存一个 hash 值 每次请求客户端就会带上 hash 值，服务器经过对比时间相同返回 304 读取浏览器缓存，不同返回 200 重新请求资源</p></blockquote></li></ul><h2 id="刷新操作-对缓存的影响" tabindex="-1">刷新操作，对缓存的影响 <a class="header-anchor" href="#刷新操作-对缓存的影响" aria-label="Permalink to &quot;刷新操作，对缓存的影响&quot;">​</a></h2><ul><li>正常操作-强制缓存有效，协议缓存有效</li><li>手动刷新(浏览器上的刷新)-强制缓存失效，协议缓存有效</li><li>强制刷新(ctrl + f5)-强制缓存失效，协议缓存失效</li></ul><h2 id="http2-0-的优势" tabindex="-1">http2.0 的优势 <a class="header-anchor" href="#http2-0-的优势" aria-label="Permalink to &quot;http2.0 的优势&quot;">​</a></h2><ul><li>采用<code>二进制格式传输数据</code>，而非 http1.1 的文本格式，二进制格式在协议的解析和优化扩展上带来更多的优势和可能</li><li>对消息头采用<code>HPACK进行压缩传输</code>，能够节省消息头占用的网络的流量，而 http1.1 每次请求，都会携带大量冗余头信息，浪费了很多带宽资源，头压缩能够很好的解决该问题</li><li><code>多路复用</code>，就是多个请求都是通过一个 TCP 连接并发完成，http1.1 虽然通过 pipeline 也能并发请求，但是多个请求之间的响应会被阻塞的，所以 pipeline 至今也没有被普及应用，而 http2.0 做到了真正的并发请求，同时，流还支持优先级和流量控制</li><li><code>Server Push</code>，服务端能够更快的把资源推送给客户端，例如服务端可以主动把 JS 和 CSS 文件推送给客户端，而不需要客户端解析 HTML 再发送这些请求，当客户端需要的时候，它已经在客户端了。</li></ul><h2 id="同源策略" tabindex="-1">同源策略 <a class="header-anchor" href="#同源策略" aria-label="Permalink to &quot;同源策略&quot;">​</a></h2><ul><li><code>协议相同</code>、<code>域名相同</code>、<code>端口相同</code></li></ul><h2 id="跨域请求限制" tabindex="-1">跨域请求限制 <a class="header-anchor" href="#跨域请求限制" aria-label="Permalink to &quot;跨域请求限制&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>跨域是浏览器的限制，和服务端无关</p></div><ul><li>Cookie localStorage 等等无法读取</li><li>dom 无法操作</li><li>ajax 不能发送，ajax 只能在同源下使用</li></ul><h2 id="那些不受同源策略的限制" tabindex="-1">那些不受同源策略的限制 <a class="header-anchor" href="#那些不受同源策略的限制" aria-label="Permalink to &quot;那些不受同源策略的限制&quot;">​</a></h2><ul><li>webSocket 不受同源策略的限制</li><li>使用 HTML5 中新引进的 window.postMessage 方法来跨域传送数据</li><li>CORS 服务器设置 header ：Access-Control-Allow-Origin</li><li>jsonp 就是利用 script 标签不受跨越限制，让服务器端返回可执行的回调函数,得到参数</li></ul><h2 id="跨域请求" tabindex="-1">跨域请求 <a class="header-anchor" href="#跨域请求" aria-label="Permalink to &quot;跨域请求&quot;">​</a></h2><ul><li>跨域如果是复杂请求会有一个<code>options预检机制</code>，预检通过成功后才会发送真正的请求</li><li>简单的有 get、post，其他都是复杂。如果用户添加了自定义信息也算复杂请求</li><li>cookie 不允许跨域</li></ul><h2 id="跨域http预检请求、嗅探请求、options请求的解决优化办法" tabindex="-1">跨域HTTP预检请求、嗅探请求、options请求的解决优化办法 <a class="header-anchor" href="#跨域http预检请求、嗅探请求、options请求的解决优化办法" aria-label="Permalink to &quot;跨域HTTP预检请求、嗅探请求、options请求的解决优化办法&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><ul><li>options（预检/嗅探请求）可能会导致请求变慢，每次进行接口请求时候，浏览器会先发出一个options请求，然后才发起正式的请求。</li></ul></div><ul><li>解决办法（优化）：可以通过设置响应头部的<code>Access-Control-Max-Age</code> 来设置预检请求有效期，即在设置的时间内只有第一次会发送出数据，下次这个接口请求（相同接口&amp;相同参数时）不会再发出这个预检请求，而是发送真请求。</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">location </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">options</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">add_header </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Access-Control-Max-Age&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 600</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">proxy_pass </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">http</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//a**********/;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="http-对比-https" tabindex="-1">http 对比 https <a class="header-anchor" href="#http-对比-https" aria-label="Permalink to &quot;http 对比 https&quot;">​</a></h2><ul><li>http 是明文传输，敏感信息容易被中间劫持</li><li>https=http+ssl 非对称加密，劫持了也无法解密</li></ul><h2 id="对称加密" tabindex="-1">对称加密 <a class="header-anchor" href="#对称加密" aria-label="Permalink to &quot;对称加密&quot;">​</a></h2><ul><li>加解密都是用的一个 key</li></ul><h2 id="非对称加密" tabindex="-1">非对称加密 <a class="header-anchor" href="#非对称加密" aria-label="Permalink to &quot;非对称加密&quot;">​</a></h2><ul><li>会生成一对<code>公(Public Key)</code> <code>私(Private key)</code>钥，用 Public Key 进行加密，Private key 解密</li><li>Private key 不会对外公开，相对安全指数高</li></ul><h2 id="http2-的多路复用" tabindex="-1">http2 的多路复用 <a class="header-anchor" href="#http2-的多路复用" aria-label="Permalink to &quot;http2 的多路复用&quot;">​</a></h2><ul><li><p>在 HTTP/1 中，每次请求都会建立一次 HTTP 连接，也就是我们常说的 3 次握手 4 次挥手，这个过程在一次请求过程中占用了相当长的时间，即使开启了 Keep-Alive ，解决了多次连接的问题，但是依然有两个效率上的问题：</p><blockquote><p>第一个：串行的文件传输。当请求 a 文件时，b 文件只能等待，等待 a 连接到服务器、服务器处理文件、服务器返回文件，这三个步骤。我们假设这三步用时都是 1 秒，那么 a 文件用时为 3 秒，b 文件传输完成用时为 6 秒，依此类推。（注：此项计算有一个前提条件，就是浏览器和服务器是单通道传输）</p></blockquote><blockquote><p>第二个：连接数过多。我们假设 Apache 设置了最大并发数为 300，因为浏览器限制，浏览器发起的最大请求数为 6，也就是服务器能承载的最高并发为 50，当第 51 个人访问时，就需要等待前面某个请求处理完成。</p></blockquote></li><li><p>HTTP/2 的多路复用就是为了解决上述的两个性能问题。 在 HTTP/2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。 帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。 多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。</p></li></ul><h2 id="https-中间人攻击" tabindex="-1">HTTPS 中间人攻击 <a class="header-anchor" href="#https-中间人攻击" aria-label="Permalink to &quot;HTTPS 中间人攻击&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>服务端在发送浏览器的公钥中加入 CA 证书，浏览器可以验证 CA 证书的有效性</p></div><ul><li>1、服务器向客户端发送公钥。</li><li>2、攻击者截获公钥，保留在自己手上。</li><li>3、然后攻击者自己生成一个【伪造的】公钥，发给客户端。</li><li>4、客户端收到伪造的公钥后，生成加密 hash 值发给服务器。</li><li>5、攻击者获得加密 hash 值，用自己的私钥解密获得真密钥。</li><li>6、同时生成假的加密 hash 值，发给服务器。</li><li>7、服务器用私钥解密获得假密钥。</li><li>8、服务器用加密钥加密传输信息</li></ul><h2 id="tcp-和-udp区别" tabindex="-1">TCP 和 UDP区别 <a class="header-anchor" href="#tcp-和-udp区别" aria-label="Permalink to &quot;TCP 和 UDP区别&quot;">​</a></h2><ul><li>TCP 面向连接（如打电话要先拨号建立连接）提供可靠的服务，UDP 是无连接的，即发送数据之前不需要建立连接，UDP 尽最大努力交付，即不保证可靠交付。</li><li>UDP 具有较好的实时性，工作效率比 TCP 高，适用于对高速传输和实时性有较高的通信或广播通信。</li><li>每一条 TCP 连接只能是一对一的，UDP 支持一对一，一对多，多对一和多对多的交互通信。</li><li>UDP 分组首部开销小，TCP 首部开销 20 字节，UDP 的首部开销小，只有 8 个字节。</li><li>TCP 面向字节流，实际上是 TCP 把数据看成一连串无结构的字节流，UDP 是面向报文的一次交付一个完整的报文，报文不可分割，报文是 UDP 数据报处理的最小单位。</li><li>UDP 适合一次性传输较小数据的网络应用，如 DNS，SNMP 等。</li></ul><h2 id="为什么有非对称加密-还需要ca证书" tabindex="-1">为什么有非对称加密，还需要CA证书？ <a class="header-anchor" href="#为什么有非对称加密-还需要ca证书" aria-label="Permalink to &quot;为什么有非对称加密，还需要CA证书？&quot;">​</a></h2><ul><li>非对称密钥加密方式也存在一些问题，就是<code>无法证明公开密钥就是接收方公开的那个密钥</code>，而不是被攻击者调包的密钥。为了解决这个问题，可以使用由数字证书认证机构（CA，Certificate Authority）和其相关机关颁发的<code>公开密钥证书</code>。<code>数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上</code>。这货就相当于是公证处，大家都相信公证处，你说你是张三别人不一定信，它说你是张三别人才能百分百信。</li></ul><h2 id="tcp-连接-三次握手-四次挥手" tabindex="-1">TCP 连接 三次握手 四次挥手 <a class="header-anchor" href="#tcp-连接-三次握手-四次挥手" aria-label="Permalink to &quot;TCP 连接 三次握手 四次挥手&quot;">​</a></h2><h3 id="三次握手" tabindex="-1">三次握手 <a class="header-anchor" href="#三次握手" aria-label="Permalink to &quot;三次握手&quot;">​</a></h3><p>过程</p><ul><li>客户端发包，服务端收到。服务端确认：客户端的发送能力是正常的。</li><li>服务端发包，客户端收到。客户端确认：服务端的接收能力是正常的。</li><li>客户端发包，服务端收到。服务端确认：客户端即将给我发送数据，我要准备接收。</li></ul><p>建立连接完成，然后就开始发送数据，通讯。</p><h3 id="四次挥手" tabindex="-1">四次挥手 <a class="header-anchor" href="#四次挥手" aria-label="Permalink to &quot;四次挥手&quot;">​</a></h3><p>握手，是建立连接。挥手，就是告别，就是关闭连接。</p><p>过程</p><ul><li>客户端发包，服务端接收。服务端确认：客户端已经请求结束</li><li>服务端发包，客户端接收。客户端确认：服务端已经收到，我等待它关闭</li><li>服务端发包：客户端接受。客户端确认：服务端已经发送完成，可以关闭</li><li>客户端发包，服务端接收。服务端确认：可以关闭了</li></ul>`,62)]))}const b=i(s,[["render",h]]);export{k as __pageData,b as default};
