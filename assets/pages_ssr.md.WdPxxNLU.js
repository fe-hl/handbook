import{_ as r,c as o,o as l,ao as s}from"./chunks/framework.DOhyS95j.js";const S=JSON.parse('{"title":"服务端渲染（SSR）与客户端渲染（CSR）","description":"","frontmatter":{},"headers":[],"relativePath":"pages/ssr.md","filePath":"pages/ssr.md","lastUpdated":1753861224000}'),a={name:"pages/ssr.md"};function n(i,t,e,g,d,h){return l(),o("div",null,t[0]||(t[0]=[s('<h1 id="服务端渲染-ssr-与客户端渲染-csr" tabindex="-1">服务端渲染（SSR）与客户端渲染（CSR） <a class="header-anchor" href="#服务端渲染-ssr-与客户端渲染-csr" aria-label="Permalink to &quot;服务端渲染（SSR）与客户端渲染（CSR）&quot;">​</a></h1><h2 id="一、传统服务端渲染-ssr" tabindex="-1"><strong>一、传统服务端渲染（SSR）</strong> <a class="header-anchor" href="#一、传统服务端渲染-ssr" aria-label="Permalink to &quot;**一、传统服务端渲染（SSR）**&quot;">​</a></h2><h3 id="原理" tabindex="-1"><strong>原理</strong> <a class="header-anchor" href="#原理" aria-label="Permalink to &quot;**原理**&quot;">​</a></h3><ol><li><p><strong>流程</strong>：</p><ul><li>客户端发送 HTTP 请求。</li><li>服务端通过模板引擎（如 EJS、JSP）拼接数据与 DOM，生成完整 HTML。</li><li>服务端返回静态 HTML，客户端直接渲染。</li></ul></li><li><p><strong>技术代表</strong>：ASP、JSP、PHP、EJS。</p></li></ol><h3 id="优点" tabindex="-1"><strong>优点</strong> <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;**优点**&quot;">​</a></h3><ul><li><strong>首屏速度快</strong>：无需等待 JS 加载，直接显示内容。</li><li><strong>SEO 友好</strong>：搜索引擎可直接抓取完整 HTML。</li><li><strong>服务端压力小</strong>：渲染由服务端完成，客户端仅展示。</li></ul><h3 id="缺点" tabindex="-1"><strong>缺点</strong> <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;**缺点**&quot;">​</a></h3><ul><li><strong>维护困难</strong>：前后端逻辑耦合，代码复用性低。</li><li><strong>用户体验差</strong>：页面跳转需重新加载，交互不流畅。</li><li><strong>开发效率低</strong>：前后端分离不彻底，协作成本高。</li></ul><h2 id="二、现代服务端渲染-同构渲染" tabindex="-1"><strong>二、现代服务端渲染（同构渲染）</strong> <a class="header-anchor" href="#二、现代服务端渲染-同构渲染" aria-label="Permalink to &quot;**二、现代服务端渲染（同构渲染）**&quot;">​</a></h2><h3 id="核心概念" tabindex="-1"><strong>核心概念</strong> <a class="header-anchor" href="#核心概念" aria-label="Permalink to &quot;**核心概念**&quot;">​</a></h3><ul><li><strong>同构</strong>：同一套代码在服务端（Node.js）和客户端运行，实现“预渲染+注水化”。</li><li><strong>技术代表</strong>：Vue SSR（Nuxt.js）、React SSR（Next.js）。</li></ul><h3 id="原理-1" tabindex="-1"><strong>原理</strong> <a class="header-anchor" href="#原理-1" aria-label="Permalink to &quot;**原理**&quot;">​</a></h3><ol><li><p><strong>流程</strong>：</p><ul><li>客户端发起请求。</li><li>服务端运行 Vue/React 应用，生成虚拟 DOM 并转为 HTML 字符串。</li><li>服务端返回 HTML，客户端激活 JS 后绑定事件（注水化）。</li></ul></li><li><p><strong>关键点</strong>：</p><ul><li><strong>预渲染</strong>：服务端生成首屏 HTML，解决首屏白屏问题。</li><li><strong>注水化</strong>：客户端接管交互逻辑，实现动态更新。</li></ul></li></ol><h3 id="优点-1" tabindex="-1"><strong>优点</strong> <a class="header-anchor" href="#优点-1" aria-label="Permalink to &quot;**优点**&quot;">​</a></h3><ul><li><strong>首屏优化</strong>：首屏内容由服务端快速生成，无需等待 JS。</li><li><strong>SEO 友好</strong>：搜索引擎可抓取预渲染的 HTML。</li><li><strong>代码复用</strong>：前后端共享组件和逻辑，降低维护成本。</li><li><strong>框架支持</strong>：Nuxt.js（Vue）、Next.js（React）提供开箱即用方案。</li></ul><h3 id="缺点-1" tabindex="-1"><strong>缺点</strong> <a class="header-anchor" href="#缺点-1" aria-label="Permalink to &quot;**缺点**&quot;">​</a></h3><ul><li><strong>服务端压力</strong>：需 Node.js 服务支撑，高并发下资源消耗大。</li><li><strong>复杂度</strong>：需处理服务端与客户端的生命周期差异。</li><li><strong>第三方库适配</strong>：部分库可能依赖浏览器 API，需特殊处理。</li></ul><h2 id="三、客户端渲染-csr" tabindex="-1"><strong>三、客户端渲染（CSR）</strong> <a class="header-anchor" href="#三、客户端渲染-csr" aria-label="Permalink to &quot;**三、客户端渲染（CSR）**&quot;">​</a></h2><h3 id="原理-2" tabindex="-1"><strong>原理</strong> <a class="header-anchor" href="#原理-2" aria-label="Permalink to &quot;**原理**&quot;">​</a></h3><ol><li><p><strong>流程</strong>：</p><ul><li>客户端发起请求。</li><li>服务端返回空 HTML + JS 文件。</li><li>客户端加载 JS，通过 Ajax 请求数据，动态渲染 DOM。</li></ul></li><li><p><strong>技术代表</strong>：Vue、React、Angular（SPA 模式）。</p></li></ol><h3 id="优点-2" tabindex="-1"><strong>优点</strong> <a class="header-anchor" href="#优点-2" aria-label="Permalink to &quot;**优点**&quot;">​</a></h3><ul><li><strong>交互流畅</strong>：页面跳转无刷新，用户体验接近原生应用。</li><li><strong>前后端分离彻底</strong>：服务端仅提供 API，开发效率高。</li><li><strong>动态更新</strong>：适合高频数据交互的场景（如社交、管理后台）。</li></ul><h3 id="缺点-2" tabindex="-1"><strong>缺点</strong> <a class="header-anchor" href="#缺点-2" aria-label="Permalink to &quot;**缺点**&quot;">​</a></h3><ul><li><strong>首屏慢</strong>：需加载 JS 并请求数据，用户可能看到白屏。</li><li><strong>SEO 困难</strong>：搜索引擎难以抓取 JS 生成的内容。</li><li><strong>依赖前端性能</strong>：低端设备可能卡顿。</li></ul><h2 id="四、对比与选型建议" tabindex="-1"><strong>四、对比与选型建议</strong> <a class="header-anchor" href="#四、对比与选型建议" aria-label="Permalink to &quot;**四、对比与选型建议**&quot;">​</a></h2><table tabindex="0"><thead><tr><th><strong>维度</strong></th><th><strong>传统 SSR</strong></th><th><strong>现代 SSR（同构）</strong></th><th><strong>CSR</strong></th></tr></thead><tbody><tr><td><strong>首屏速度</strong></td><td>快</td><td>快</td><td>慢</td></tr><tr><td><strong>SEO</strong></td><td>友好</td><td>友好</td><td>不友好</td></tr><tr><td><strong>开发效率</strong></td><td>低（前后端耦合）</td><td>中（需 Node.js）</td><td>高（前后端完全分离）</td></tr><tr><td><strong>维护成本</strong></td><td>高</td><td>中</td><td>低</td></tr><tr><td><strong>适用场景</strong></td><td>官网、电商列表页</td><td>需要 SEO 的首屏、内容型网站</td><td>管理后台、社交应用</td></tr></tbody></table><h3 id="优化方向" tabindex="-1"><strong>优化方向</strong> <a class="header-anchor" href="#优化方向" aria-label="Permalink to &quot;**优化方向**&quot;">​</a></h3><ul><li><p><strong>CSR 优化</strong>：</p><ul><li><strong>代码分割</strong>：按路由/组件拆分 JS，减少首屏加载量。</li><li><strong>预加载</strong>：利用<code>&lt;link rel=&quot;preload&quot;&gt;</code>提前加载关键资源。</li><li><strong>骨架屏</strong>：首屏加载时显示占位内容，提升感知速度。</li><li><strong>服务端渲染混合</strong>：对关键页面采用 SSR，其他页面 CSR。</li></ul></li><li><p><strong>现代 SSR 优化</strong>：</p><ul><li><strong>缓存</strong>：对不常变更的页面缓存 HTML，减少服务端渲染耗时。</li><li><strong>流式渲染</strong>：分块传输 HTML，优先显示首屏内容。</li><li><strong>Node.js 集群</strong>：通过集群部署提升并发能力。</li></ul></li></ul><h2 id="五、总结" tabindex="-1"><strong>五、总结</strong> <a class="header-anchor" href="#五、总结" aria-label="Permalink to &quot;**五、总结**&quot;">​</a></h2><ul><li><strong>优先选 CSR</strong>：若项目注重交互体验、无需 SEO（如内部系统），或首屏内容可通过懒加载优化。</li><li><strong>优先选现代 SSR</strong>：若需兼顾 SEO 与动态交互（如电商、新闻网站），且能接受服务端复杂度。</li><li><strong>传统 SSR</strong>：仅在 legacy 系统维护时使用，新项目建议直接采用现代 SSR 框架（如 Nuxt.js/Next.js）。</li></ul>',30)]))}const c=r(a,[["render",n]]);export{S as __pageData,c as default};
