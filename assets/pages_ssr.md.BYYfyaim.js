import{_ as o,c as r,o as e,ao as l}from"./chunks/framework.DOhyS95j.js";const h=JSON.parse('{"title":"服务端渲染（SSR）与客户端渲染（CSR）","description":"","frontmatter":{},"headers":[],"relativePath":"pages/ssr.md","filePath":"pages/ssr.md"}'),s={name:"pages/ssr.md"};function n(a,t,i,g,d,u){return e(),r("div",null,t[0]||(t[0]=[l('<h1 id="服务端渲染-ssr-与客户端渲染-csr" tabindex="-1">服务端渲染（SSR）与客户端渲染（CSR） <a class="header-anchor" href="#服务端渲染-ssr-与客户端渲染-csr" aria-label="Permalink to &quot;服务端渲染（SSR）与客户端渲染（CSR）&quot;">​</a></h1><h2 id="一、传统服务端渲染-ssr" tabindex="-1"><strong>一、传统服务端渲染（SSR）</strong> <a class="header-anchor" href="#一、传统服务端渲染-ssr" aria-label="Permalink to &quot;**一、传统服务端渲染（SSR）**&quot;">​</a></h2><h3 id="原理" tabindex="-1"><strong>原理</strong> <a class="header-anchor" href="#原理" aria-label="Permalink to &quot;**原理**&quot;">​</a></h3><ol><li><p><strong>流程</strong>：</p><ul><li>客户端发送 HTTP 请求。</li><li>服务端通过模板引擎（如 EJS、JSP）拼接数据与 DOM，生成完整 HTML。</li><li>服务端返回静态 HTML，客户端直接渲染。</li></ul></li><li><p><strong>技术代表</strong>：ASP、JSP、PHP、EJS。</p></li></ol><h3 id="优点" tabindex="-1"><strong>优点</strong> <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;**优点**&quot;">​</a></h3><ul><li><strong>首屏速度快</strong>：无需等待 JS 加载，直接显示内容。</li><li><strong>SEO 友好</strong>：搜索引擎可直接抓取完整 HTML。</li><li><strong>服务端压力小</strong>：渲染由服务端完成，客户端仅展示。</li></ul><h3 id="缺点" tabindex="-1"><strong>缺点</strong> <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;**缺点**&quot;">​</a></h3><ul><li><strong>维护困难</strong>：前后端逻辑耦合，代码复用性低。</li><li><strong>用户体验差</strong>：页面跳转需重新加载，交互不流畅。</li><li><strong>开发效率低</strong>：前后端分离不彻底，协作成本高。</li></ul><h2 id="二、现代服务端渲染-同构渲染" tabindex="-1"><strong>二、现代服务端渲染（同构渲染）</strong> <a class="header-anchor" href="#二、现代服务端渲染-同构渲染" aria-label="Permalink to &quot;**二、现代服务端渲染（同构渲染）**&quot;">​</a></h2><h3 id="核心概念" tabindex="-1"><strong>核心概念</strong> <a class="header-anchor" href="#核心概念" aria-label="Permalink to &quot;**核心概念**&quot;">​</a></h3><ul><li><strong>同构</strong>：同一套代码在服务端（Node.js）和客户端运行，实现“预渲染+注水化”。</li><li><strong>技术代表</strong>：Vue SSR（Nuxt.js）、React SSR（Next.js）。</li></ul><h3 id="原理-1" tabindex="-1"><strong>原理</strong> <a class="header-anchor" href="#原理-1" aria-label="Permalink to &quot;**原理**&quot;">​</a></h3><ol><li><p><strong>流程</strong>：</p><ul><li>客户端发起请求。</li><li>服务端运行 Vue/React 应用，生成虚拟 DOM 并转为 HTML 字符串。</li><li>服务端返回 HTML，客户端激活 JS 后绑定事件（注水化）。</li></ul></li><li><p><strong>关键点</strong>：</p><ul><li><strong>预渲染</strong>：服务端生成首屏 HTML，解决首屏白屏问题。</li><li><strong>注水化</strong>：客户端接管交互逻辑，实现动态更新。</li></ul></li></ol><h3 id="优点-1" tabindex="-1"><strong>优点</strong> <a class="header-anchor" href="#优点-1" aria-label="Permalink to &quot;**优点**&quot;">​</a></h3><ul><li><strong>首屏优化</strong>：首屏内容由服务端快速生成，无需等待 JS。</li><li><strong>SEO 友好</strong>：搜索引擎可抓取预渲染的 HTML。</li><li><strong>代码复用</strong>：前后端共享组件和逻辑，降低维护成本。</li><li><strong>框架支持</strong>：Nuxt.js（Vue）、Next.js（React）提供开箱即用方案。</li></ul><h3 id="缺点-1" tabindex="-1"><strong>缺点</strong> <a class="header-anchor" href="#缺点-1" aria-label="Permalink to &quot;**缺点**&quot;">​</a></h3><ul><li><strong>服务端压力</strong>：需 Node.js 服务支撑，高并发下资源消耗大。</li><li><strong>复杂度</strong>：需处理服务端与客户端的生命周期差异。</li><li><strong>第三方库适配</strong>：部分库可能依赖浏览器 API，需特殊处理。</li></ul><h2 id="三、客户端渲染-csr" tabindex="-1"><strong>三、客户端渲染（CSR）</strong> <a class="header-anchor" href="#三、客户端渲染-csr" aria-label="Permalink to &quot;**三、客户端渲染（CSR）**&quot;">​</a></h2><h3 id="原理-2" tabindex="-1"><strong>原理</strong> <a class="header-anchor" href="#原理-2" aria-label="Permalink to &quot;**原理**&quot;">​</a></h3><ol><li><p><strong>流程</strong>：</p><ul><li>客户端发起请求。</li><li>服务端返回空 HTML + JS 文件。</li><li>客户端加载 JS，通过 Ajax 请求数据，动态渲染 DOM。</li></ul></li><li><p><strong>技术代表</strong>：Vue、React、Angular（SPA 模式）。</p></li></ol><h3 id="优点-2" tabindex="-1"><strong>优点</strong> <a class="header-anchor" href="#优点-2" aria-label="Permalink to &quot;**优点**&quot;">​</a></h3><ul><li><strong>交互流畅</strong>：页面跳转无刷新，用户体验接近原生应用。</li><li><strong>前后端分离彻底</strong>：服务端仅提供 API，开发效率高。</li><li><strong>动态更新</strong>：适合高频数据交互的场景（如社交、管理后台）。</li></ul><h3 id="缺点-2" tabindex="-1"><strong>缺点</strong> <a class="header-anchor" href="#缺点-2" aria-label="Permalink to &quot;**缺点**&quot;">​</a></h3><ul><li><strong>首屏慢</strong>：需加载 JS 并请求数据，用户可能看到白屏。</li><li><strong>SEO 困难</strong>：搜索引擎难以抓取 JS 生成的内容。</li><li><strong>依赖前端性能</strong>：低端设备可能卡顿。</li></ul><h2 id="四、对比与选型建议" tabindex="-1"><strong>四、对比与选型建议</strong> <a class="header-anchor" href="#四、对比与选型建议" aria-label="Permalink to &quot;**四、对比与选型建议**&quot;">​</a></h2><table tabindex="0"><thead><tr><th><strong>维度</strong></th><th><strong>传统 SSR</strong></th><th><strong>现代 SSR（同构）</strong></th><th><strong>CSR</strong></th></tr></thead><tbody><tr><td><strong>首屏速度</strong></td><td>快</td><td>快</td><td>慢</td></tr><tr><td><strong>SEO</strong></td><td>友好</td><td>友好</td><td>不友好</td></tr><tr><td><strong>开发效率</strong></td><td>低（前后端耦合）</td><td>中（需 Node.js）</td><td>高（前后端完全分离）</td></tr><tr><td><strong>维护成本</strong></td><td>高</td><td>中</td><td>低</td></tr><tr><td><strong>适用场景</strong></td><td>官网、电商列表页</td><td>需要 SEO 的首屏、内容型网站</td><td>管理后台、社交应用</td></tr></tbody></table><h3 id="优化方向" tabindex="-1"><strong>优化方向</strong> <a class="header-anchor" href="#优化方向" aria-label="Permalink to &quot;**优化方向**&quot;">​</a></h3><ul><li><p><strong>CSR 优化</strong>：</p><ul><li><strong>代码分割</strong>：按路由/组件拆分 JS，减少首屏加载量。</li><li><strong>预加载</strong>：利用<code>&lt;link rel=&quot;preload&quot;&gt;</code>提前加载关键资源。</li><li><strong>骨架屏</strong>：首屏加载时显示占位内容，提升感知速度。</li><li><strong>服务端渲染混合</strong>：对关键页面采用 SSR，其他页面 CSR。</li></ul></li><li><p><strong>现代 SSR 优化</strong>：</p><ul><li><strong>缓存</strong>：对不常变更的页面缓存 HTML，减少服务端渲染耗时。</li><li><strong>流式渲染</strong>：分块传输 HTML，优先显示首屏内容。</li><li><strong>Node.js 集群</strong>：通过集群部署提升并发能力。</li></ul></li></ul><h2 id="五、总结" tabindex="-1"><strong>五、总结</strong> <a class="header-anchor" href="#五、总结" aria-label="Permalink to &quot;**五、总结**&quot;">​</a></h2><ul><li><strong>优先选 CSR</strong>：若项目注重交互体验、无需 SEO（如内部系统），或首屏内容可通过懒加载优化。</li><li><strong>优先选现代 SSR</strong>：若需兼顾 SEO 与动态交互（如电商、新闻网站），且能接受服务端复杂度。</li><li><strong>传统 SSR</strong>：仅在 legacy 系统维护时使用，新项目建议直接采用现代 SSR 框架（如 Nuxt.js/Next.js）。</li></ul><h2 id="next-js-page-router-和-app-router-分析" tabindex="-1">Next.js Page Router 和 App Router 分析 <a class="header-anchor" href="#next-js-page-router-和-app-router-分析" aria-label="Permalink to &quot;Next.js Page Router 和 App Router 分析&quot;">​</a></h2><h3 id="一、核心架构与设计哲学区别" tabindex="-1">一、核心架构与设计哲学区别 <a class="header-anchor" href="#一、核心架构与设计哲学区别" aria-label="Permalink to &quot;一、核心架构与设计哲学区别&quot;">​</a></h3><ol><li><p><strong>设计哲学与诞生背景</strong></p><ul><li><strong>Pages Router</strong>：是 Next.js 早期的、稳定的路由方案。它的设计理念是 <strong>“页面即路由”</strong> 。每个文件就是一个页面，路由由文件系统决定。它建立在传统的 <strong>CSR (客户端渲染)</strong> 和 <strong>SSR (服务端渲染)</strong> 之上，是对传统 SPA 的增强。</li><li><strong>App Router</strong>：是 Next.js 13+ 推出的现代路由方案，基于 <strong>React Server Components (RSC)</strong> 构建。它的设计理念是 <strong>“应用由组件构成”</strong> ，并默认这些组件应该在服务端运行。它引入了<strong>服务端组件</strong>和<strong>客户端组件</strong>的概念，旨在实现更极致的性能优化和更丰富的开发体验。</li></ul></li><li><p><strong>目录结构</strong></p><ul><li><strong>Pages Router</strong>: 使用 <code>/pages</code> 目录。文件路径即路由。例如 <code>pages/about.js</code> 对应 <code>/about</code> 路由。</li><li><strong>App Router</strong>: 使用 <code>/app</code> 目录。路由由文件夹定义，而 UI（页面、布局、加载等）由文件夹内的特殊文件定义。例如 <code>/app/about/page.js</code> 对应 <code>/about</code> 路由。这种结构允许在同一路由段内共置多个文件（<code>layout.js</code>, <code>page.js</code>, <code>loading.js</code>等）。</li></ul></li></ol><h3 id="二、渲染模式区别" tabindex="-1">二、渲染模式区别 <a class="header-anchor" href="#二、渲染模式区别" aria-label="Permalink to &quot;二、渲染模式区别&quot;">​</a></h3><h4 id="pages-router-的渲染模式" tabindex="-1">Pages Router 的渲染模式 <a class="header-anchor" href="#pages-router-的渲染模式" aria-label="Permalink to &quot;Pages Router 的渲染模式&quot;">​</a></h4><p>Pages Router 的渲染发生在<strong>页面级别</strong>。一个页面要么是 <strong>SSG</strong>，要么是 <strong>SSR</strong>，要么是 <strong>CSR</strong>。</p><ul><li><p><strong>SSG (静态站点生成)</strong>:</p><ul><li>使用 <code>getStaticProps</code>。</li><li><strong>过程</strong>：在构建时（<code>next build</code>）运行 <code>getStaticProps</code> 获取数据，生成静态 HTML 文件。用户请求时，直接返回该 HTML，然后进行客户端注水（Hydration），变为可交互页面。</li><li><strong>优点</strong>：性能极快，适合内容不变的页面。</li></ul></li><li><p><strong>SSR (服务端渲染)</strong>:</p><ul><li>使用 <code>getServerSideProps</code>。</li><li><strong>过程</strong>：用户每次请求时，服务器运行 <code>getServerSideProps</code> 获取数据，然后使用该数据在服务端渲染出完整的 HTML，再发送给客户端。客户端接收后同样进行注水。</li><li><strong>优点</strong>：适合需要每次请求都获取最新数据的页面（如仪表盘）。</li></ul></li><li><p><strong>CSR (客户端渲染)</strong>:</p><ul><li>在 <code>useEffect</code> 或组件挂载后获取数据。</li><li><strong>过程</strong>：服务器返回一个空的 HTML Shell 和 JS 包。浏览器加载 JS 后，在客户端运行 React 渲染页面并获取数据。</li><li><strong>优点</strong>：减轻服务器压力，但不利于 SEO 和初始加载性能。</li></ul></li></ul><p><strong>在 Pages Router 中，整个页面作为一个整体遵循一种渲染策略。</strong></p><h4 id="app-router-的渲染模式" tabindex="-1">App Router 的渲染模式 <a class="header-anchor" href="#app-router-的渲染模式" aria-label="Permalink to &quot;App Router 的渲染模式&quot;">​</a></h4><p>App Router 的渲染发生在<strong>组件级别</strong>，引入了革命性的 <strong>React Server Components</strong>。</p><ul><li><p><strong>服务端组件 (Server Components)</strong>:</p><ul><li><strong>默认行为</strong>：<code>/app</code> 目录下的所有组件默认都是服务端组件。</li><li><strong>过程</strong>：在<strong>服务器上</strong>渲染，<strong>永远不会被发送到客户端</strong>。它们可以直接访问后端资源（数据库、API），使用异步 <code>await</code> 获取数据。渲染结果是一段轻量的 <strong>RSC Payload</strong> (一种描述 UI 的序列化数据流)，被发送到客户端。</li><li><strong>优点</strong>： <ul><li><strong>零打包大小</strong>：组件代码不进入 JS Bundle，极大减少客户端体积。</li><li><strong>直接数据访问</strong>：更安全、更快速。</li><li><strong>自动代码拆分</strong>：天然实现。</li></ul></li></ul></li><li><p><strong>客户端组件 (Client Components)</strong>:</p><ul><li>需要在文件顶部添加 <code>&quot;use client&quot;</code> 指令。</li><li><strong>过程</strong>：它们在服务端预渲染（类似 SSR），但<strong>其代码会被发送到客户端</strong>，并在浏览器中进行注水，变得可交互。它们可以使用状态（<code>useState</code>）、效果（<code>useEffect</code>）和事件处理器。</li><li><strong>角色</strong>：专门用于添加交互性。</li></ul></li><li><p><strong>混合渲染与流式渲染 (Streaming)</strong>:</p><ul><li><strong>混合</strong>：一个页面可以由多个服务端组件和客户端组件嵌套组成。例如，一个静态的 <code>Layout</code>（服务端组件）内部包含一个需要交互的 <code>Button</code>（客户端组件）。</li><li><strong>流式渲染</strong>：这是 App Router 的巨大优势。通过 <code>Suspense</code> 边界，页面可以逐步渲染。不需要等待所有数据获取完成，而是先发送已经准备好的部分 HTML 到客户端显示。这极大提升了<strong>首次内容绘制 (FCP)</strong> 和<strong>首次输入延迟 (FID)</strong> 指标，用户体验更流畅。</li><li><strong>过程对比</strong>：想象一个页面有头部、主体和侧边栏。在 Pages Router 中，必须等所有数据都获取完毕才能一次性发送整个页面。在 App Router 中，头部（静态）可以立刻发送并显示，主体（需要慢查询）被 <code>Suspense</code> 包裹，显示一个 <code>loading.js</code> Fallback，等主体数据准备好后再流式传输过来。</li></ul></li></ul><h3 id="三、功能特性区别-简要提及" tabindex="-1">三、功能特性区别（简要提及） <a class="header-anchor" href="#三、功能特性区别-简要提及" aria-label="Permalink to &quot;三、功能特性区别（简要提及）&quot;">​</a></h3><table tabindex="0"><thead><tr><th style="text-align:left;">特性</th><th style="text-align:left;">Pages Router</th><th style="text-align:left;">App Router</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>数据获取</strong></td><td style="text-align:left;"><code>getStaticProps</code>, <code>getServerSideProps</code></td><td style="text-align:left;">在 Server Component 中直接使用 <code>fetch</code></td></tr><tr><td style="text-align:left;"><strong>布局</strong></td><td style="text-align:left;">通过 <code>_app.js</code> 实现，复杂嵌套较麻烦</td><td style="text-align:left;">原生 <code>layout.js</code>，支持嵌套，状态保持</td></tr><tr><td style="text-align:left;"><strong>加载状态</strong></td><td style="text-align:left;">手动实现</td><td style="text-align:left;">内置 <code>loading.js</code>，基于 <code>Suspense</code></td></tr><tr><td style="text-align:left;"><strong>错误处理</strong></td><td style="text-align:left;"><code>_error.js</code></td><td style="text-align:left;">更精细的 <code>error.js</code> (组件级错误)</td></tr><tr><td style="text-align:left;"><strong>SEO</strong></td><td style="text-align:left;">使用 <code>next/head</code></td><td style="text-align:left;">基于配置的 <code>metadata</code> API</td></tr></tbody></table>',43)]))}const p=o(s,[["render",n]]);export{h as __pageData,p as default};
