import{_ as a,c as l,o as i,ao as o}from"./chunks/framework.BYLdZtYo.js";const b=JSON.parse('{"title":"webpack","description":"","frontmatter":{},"headers":[],"relativePath":"pages/webpack.md","filePath":"pages/webpack.md","lastUpdated":1691663709000}'),t={name:"pages/webpack.md"};function r(c,e,d,n,u,p){return i(),l("div",null,e[0]||(e[0]=[o('<h1 id="webpack" tabindex="-1">webpack <a class="header-anchor" href="#webpack" aria-label="Permalink to &quot;webpack&quot;">​</a></h1><h2 id="webpack介绍" tabindex="-1">webpack介绍 <a class="header-anchor" href="#webpack介绍" aria-label="Permalink to &quot;webpack介绍&quot;">​</a></h2><ul><li>webpack是一个JavaScript 应用程序的静态模块打包工具</li></ul><h2 id="入口-entry" tabindex="-1">入口(entry) <a class="header-anchor" href="#入口-entry" aria-label="Permalink to &quot;入口(entry)&quot;">​</a></h2><ul><li>入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部 依赖图(dependency graph) 的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的</li></ul><h2 id="输出-output" tabindex="-1">输出(output) <a class="header-anchor" href="#输出-output" aria-label="Permalink to &quot;输出(output)&quot;">​</a></h2><ul><li>output 属性告诉 webpack 在哪里输出它所创建的 bundle，以及如何命名这些文件</li></ul><h2 id="loader" tabindex="-1">loader <a class="header-anchor" href="#loader" aria-label="Permalink to &quot;loader&quot;">​</a></h2><ul><li>webpack 只能理解 JavaScript 和 JSON 文件</li><li>loader 让 webpack 能够去处理其他类型的文件，并将它们转换为有效模块，以供应用程序使用，以及被添加到依赖图中</li><li>多个loader，回从右往左执行</li></ul><h2 id="插件-plugin" tabindex="-1">插件(plugin) <a class="header-anchor" href="#插件-plugin" aria-label="Permalink to &quot;插件(plugin)&quot;">​</a></h2><ul><li>loader 用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。包括：打包优化，资源管理，注入环境变量</li></ul><h2 id="webpack-编译流程" tabindex="-1">webpack 编译流程 <a class="header-anchor" href="#webpack-编译流程" aria-label="Permalink to &quot;webpack 编译流程&quot;">​</a></h2><ul><li>1、初始化参数：从配置文件和 Shell 语句中读取参数并且和webpack<code>参数进行合并</code>,得出最终的配置对象</li><li>2、用上一步得到的参数<code>初始化 Compiler </code>对象</li><li>3、加载所有的<code>plugin</code>配置的插件，调用插件的<code>apply</code>函数并且传递Compiler 对象</li><li>4、执行Compiler对象的 run 方法开始执行编译</li><li>5、根据配置中的entry找出入口文件</li><li>6、从入口文件出发,调用所有配置的<code>Loader</code>对模块进行编译</li><li>7、再找出该模块依赖的模块，再<code>递归</code>直到所有入口依赖的文件都经过了本步骤的处理</li><li>8、根据入口和<code>模块之间的依赖关系</code>，组装成一个个包含<code>多个模块的 Chunk</code></li><li>9、再把每个 <code>Chunk 转换成一个单独的文件</code>加入到输出列表</li><li>10、在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统</li></ul><h2 id="module、chunk、bundlle" tabindex="-1">module、chunk、bundlle <a class="header-anchor" href="#module、chunk、bundlle" aria-label="Permalink to &quot;module、chunk、bundlle&quot;">​</a></h2><ul><li>module：各个源码文件，webpack 中一切皆模块</li><li>chunk：多模块合并成的，如entry importo splitChunk</li><li>bundlle：最终的输出文件</li></ul>',15)]))}const k=a(t,[["render",r]]);export{b as __pageData,k as default};
