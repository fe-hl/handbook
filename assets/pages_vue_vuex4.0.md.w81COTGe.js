import{_ as i,c as a,o as t,ao as n}from"./chunks/framework.DOhyS95j.js";const E=JSON.parse('{"title":"Vuex4.0 核心原理与实现解析","description":"","frontmatter":{},"headers":[],"relativePath":"pages/vue/vuex4.0.md","filePath":"pages/vue/vuex4.0.md","lastUpdated":1751010556000}'),l={name:"pages/vue/vuex4.0.md"};function h(e,s,p,k,r,d){return t(),a("div",null,s[0]||(s[0]=[n(`<h1 id="vuex4-0-核心原理与实现解析" tabindex="-1">Vuex4.0 核心原理与实现解析 <a class="header-anchor" href="#vuex4-0-核心原理与实现解析" aria-label="Permalink to &quot;Vuex4.0 核心原理与实现解析&quot;">​</a></h1><p>源码实现地址：<a href="https://gitee.com/hl-fe/fe-handbook/tree/master/code/vuex4.0" target="_blank" rel="noreferrer">Vuex4.0 源码实现</a></p><h2 id="vuex-概述" tabindex="-1">Vuex 概述 <a class="header-anchor" href="#vuex-概述" aria-label="Permalink to &quot;Vuex 概述&quot;">​</a></h2><p>Vuex 是 Vue.js 中的<strong>状态管理工具</strong>，提供了一种<strong>集中式存储管理</strong>应用程序中所有组件状态的方法。其核心目的是：</p><ul><li>实现组件之间的状态共享</li><li>快速响应数据变化</li><li>对复杂多交互行为进行封装和解耦</li></ul><h2 id="核心概念" tabindex="-1">核心概念 <a class="header-anchor" href="#核心概念" aria-label="Permalink to &quot;核心概念&quot;">​</a></h2><table tabindex="0"><thead><tr><th>概念</th><th>描述</th></tr></thead><tbody><tr><td><strong>state</strong></td><td>单一状态树，将需要管理的状态抽离出来形成全局单一状态集合</td></tr><tr><td><strong>getters</strong></td><td>类似于 computed 属性，监听 state 变化返回计算值</td></tr><tr><td><strong>mutations</strong></td><td>修改状态值的函数，接收 state 对象作为参数（<strong>必须同步</strong>）</td></tr><tr><td><strong>actions</strong></td><td>异步操作，触发 mutation 来更新状态</td></tr><tr><td><strong>module</strong></td><td>大型项目中划分功能模块，便于维护和管理</td></tr></tbody></table><h2 id="vuex-执行流程" tabindex="-1">Vuex 执行流程 <a class="header-anchor" href="#vuex-执行流程" aria-label="Permalink to &quot;Vuex 执行流程&quot;">​</a></h2><ol><li><p><strong>初始化阶段</strong></p><ul><li>通过 <code>Vue.use(Store)</code> 安装时，调用 <code>createStore()</code> 创建 Store 实例</li><li>Store 内部通过 <code>provide</code> 将实例注入到根组件</li></ul></li><li><p><strong>状态注册</strong></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 示例：创建 Store</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> store</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createStore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  state: { count: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  mutations: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    increment</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      state.count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  actions: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    asyncIncrement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">commit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> commit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;increment&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div></li><li><p><strong>模块处理</strong></p><ul><li>递归安装所有模块，将子模块 state 挂载到根 state</li><li>通过命名空间对 getters、mutations、actions 进行分类存储</li></ul></li><li><p><strong>响应式处理</strong></p><ul><li>使用 Vue 的 <code>reactive</code> 将根 state 转换为响应式数据</li></ul></li><li><p><strong>状态更新</strong></p><ul><li><code>dispatch()</code> 触发 actions</li><li><code>commit()</code> 触发 mutations</li></ul></li><li><p><strong>组件使用</strong></p><ul><li>通过 <code>useStore()</code> 获取 Store 实例</li><li>内部使用 <code>inject</code> 从根组件查找 Store</li></ul></li></ol><h2 id="核心问题解析" tabindex="-1">核心问题解析 <a class="header-anchor" href="#核心问题解析" aria-label="Permalink to &quot;核心问题解析&quot;">​</a></h2><h3 id="为什么-mutations-不能异步" tabindex="-1">为什么 mutations 不能异步？ <a class="header-anchor" href="#为什么-mutations-不能异步" aria-label="Permalink to &quot;为什么 mutations 不能异步？&quot;">​</a></h3><ul><li><strong>状态追踪</strong>：每个 mutation 执行后对应一个新的状态变更，devtools 可以记录快照</li><li><strong>Time-travel 调试</strong>：异步操作会导致无法确定状态更新时机，破坏调试能力</li><li><strong>设计原则</strong>：Mutation 必须是同步函数，确保状态变更可预测</li></ul><h3 id="actions-vs-mutations" tabindex="-1">Actions vs Mutations <a class="header-anchor" href="#actions-vs-mutations" aria-label="Permalink to &quot;Actions vs Mutations&quot;">​</a></h3><table tabindex="0"><thead><tr><th>特性</th><th>Actions</th><th>Mutations</th></tr></thead><tbody><tr><td><strong>异步支持</strong></td><td>✅ 支持异步操作</td><td>❌ 仅支持同步</td></tr><tr><td><strong>调用方式</strong></td><td><code>dispatch()</code></td><td><code>commit()</code></td></tr><tr><td><strong>状态修改</strong></td><td>间接通过 mutation</td><td>直接修改 state</td></tr><tr><td><strong>组合能力</strong></td><td>可提交多个 mutation</td><td>单一状态变更</td></tr></tbody></table><h3 id="为什么必须使用-commit-dispatch" tabindex="-1">为什么必须使用 commit()/dispatch()？ <a class="header-anchor" href="#为什么必须使用-commit-dispatch" aria-label="Permalink to &quot;为什么必须使用 commit()/dispatch()？&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Store 内部实现核心</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Store</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">options</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">._mutations </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Object.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">create</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">._actions </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Object.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">create</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 收集 mutations 和 actions</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  commit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">payload</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> entry</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">._mutations[type];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    entry </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> entry</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(payload);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  dispatch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">payload</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> entry</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">._actions[type];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> entry</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(payload);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 没有直接暴露 mutation 方法</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li><strong>架构约束</strong>：Store 类不直接暴露 mutation 方法，只能通过 commit 触发</li><li><strong>调试能力</strong>：统一入口便于 devtools 跟踪状态变更</li><li><strong>代码维护</strong>：避免组件直接修改 state 导致难以追踪的变化</li></ul><h3 id="为什么不能直接修改-state" tabindex="-1">为什么不能直接修改 state？ <a class="header-anchor" href="#为什么不能直接修改-state" aria-label="Permalink to &quot;为什么不能直接修改 state？&quot;">​</a></h3><ul><li><strong>可维护性</strong>：集中修改路径便于追踪状态变化来源</li><li><strong>约束性</strong>：防止多组件随意修改导致的不可预测行为</li><li><strong>响应式保障</strong>：确保 Vue 的响应式系统正确追踪状态依赖</li></ul><h3 id="为什么异步操作必须通过-dispatch" tabindex="-1">为什么异步操作必须通过 dispatch()？ <a class="header-anchor" href="#为什么异步操作必须通过-dispatch" aria-label="Permalink to &quot;为什么异步操作必须通过 dispatch()？&quot;">​</a></h3><ul><li><strong>设计分离</strong>： <ul><li>commit() 使用同步方式调用 mutations</li><li>dispatch() 使用 Promise.all 处理异步操作</li></ul></li><li><strong>错误处理</strong>：dispatch() 返回 Promise 便于异步错误捕获</li><li><strong>执行上下文</strong>：actions 可获取完整 store 上下文（commit, state, getters）</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// dispatch 异步处理实现</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">dispatch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, payload) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> entry</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">._actions[type]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">all</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(entry.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">handler</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> handler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(payload)))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="最佳实践" tabindex="-1">最佳实践 <a class="header-anchor" href="#最佳实践" aria-label="Permalink to &quot;最佳实践&quot;">​</a></h2><ol><li>组件中通过 <code>computed</code> 获取 state</li><li>使用 <code>mapState</code>/<code>mapGetters</code> 简化状态获取</li><li>复杂业务逻辑放在 actions 中处理</li><li>大型项目使用 modules 进行状态分区</li><li>始终通过 commit 修改状态，保持可追踪性</li></ol><p><strong>设计哲学</strong>：Vuex 通过强制规范状态修改路径，在灵活性和可维护性之间取得平衡，为复杂应用提供可预测的状态管理方案。</p>`,25)]))}const g=i(l,[["render",h]]);export{E as __pageData,g as default};
