import{_ as a,c as e,o as i,ao as t}from"./chunks/framework.BYLdZtYo.js";const m=JSON.parse('{"title":"ssr服务端渲染","description":"","frontmatter":{},"headers":[],"relativePath":"pages/ssr.md","filePath":"pages/ssr.md","lastUpdated":1695781459000}'),o={name:"pages/ssr.md"};function r(s,l,d,h,c,u){return i(),e("div",null,l[0]||(l[0]=[t('<h1 id="ssr服务端渲染" tabindex="-1">ssr服务端渲染 <a class="header-anchor" href="#ssr服务端渲染" aria-label="Permalink to &quot;ssr服务端渲染&quot;">​</a></h1><h2 id="传统服务端渲染" tabindex="-1">传统服务端渲染 <a class="header-anchor" href="#传统服务端渲染" aria-label="Permalink to &quot;传统服务端渲染&quot;">​</a></h2><ul><li>传统的服务端渲染有：<code>asp</code>、<code>jsp</code>、<code>ejs</code>等，服务端语言往往通过这些模板引擎将<code>数据和dom在服务端渲染完成</code>，返回一个完整的静态html页面给客户端，由客户端直接显示。</li></ul><h3 id="原理" tabindex="-1">原理 <a class="header-anchor" href="#原理" aria-label="Permalink to &quot;原理&quot;">​</a></h3><ul><li><ol><li>客户端发送http请求</li></ol></li><li><ol start="2"><li>服务端响应http请求，返回拼接好的htm!字符串给客户端</li></ol></li><li><ol start="3"><li>客户端渲染html</li></ol></li></ul><h3 id="缺点" tabindex="-1">缺点 <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;缺点&quot;">​</a></h3><ul><li>前后端分离，不好维护</li><li>用户体验不佳，需要重新加载页面</li><li>服务端压力大</li></ul><h2 id="现代服务端渲染-同构" tabindex="-1">现代服务端渲染(同构) <a class="header-anchor" href="#现代服务端渲染-同构" aria-label="Permalink to &quot;现代服务端渲染(同构)&quot;">​</a></h2><ul><li>vue、React的SSR方案实际上就是<code>同构渲染</code>，我们现在讲的服务端渲染概念，是指在前端范畴或者说在vue、react等单页面技术栈范畴内，基于Node.js server运行环境的服务端渲染方案，通过在 Nodejs 中运行相同应用程序的前端框架 （例如 React、vue等），将其<code>预渲染成 HTML</code>，最后在<code>客户端进行注水化处理</code>。简单来讲，就是应用程序的大部分代码在<code>服务器</code>（node服务端）和<code>客户端</code>上运行，这就是所谓的现代服务端渲染：同构。</li></ul><h3 id="原理-1" tabindex="-1">原理 <a class="header-anchor" href="#原理-1" aria-label="Permalink to &quot;原理&quot;">​</a></h3><ul><li><ol><li>客户端发起http请求</li></ol></li><li><ol start="2"><li>服务端渲染把 vue 实例转换成了静态的 html 发送给客户端</li></ol></li><li><ol start="3"><li>客户端渲染是需要把事件、响应式特性等 vue 的特性都绑回去</li></ol></li></ul><h3 id="缺点-1" tabindex="-1">缺点 <a class="header-anchor" href="#缺点-1" aria-label="Permalink to &quot;缺点&quot;">​</a></h3><ul><li>服务器压力大</li><li>涉及构建设置和部署的更多要求</li><li>一些三方库可能需要特殊处理</li></ul><h3 id="优点" tabindex="-1">优点 <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点&quot;">​</a></h3><ul><li>首屏速度快</li><li>前后端分离</li><li>利于SEO</li><li>有一些现成框架：Nuxtjs、 Next.js</li></ul><h2 id="csr客户端渲染" tabindex="-1">CSR客户端渲染 <a class="header-anchor" href="#csr客户端渲染" aria-label="Permalink to &quot;CSR客户端渲染&quot;">​</a></h2><ul><li>在现代化的前端项目中，客户端渲染的代表性技术栈是vue、react、angular，我们常常使用它们来构建客户端单页或者多页应用程序。以SPA构建为例，览器端首先渲染的是一套空的html，通过JS直接进行页面的渲染和路由跳转等操作，所有的数据通过ajax请求从服务器获取后，在进行客户端的拼装和展示。</li></ul><h3 id="原理-2" tabindex="-1">原理 <a class="header-anchor" href="#原理-2" aria-label="Permalink to &quot;原理&quot;">​</a></h3><ul><li><ol><li>客户端发起http请求</li></ol></li><li><ol start="2"><li>服务端响应http请求，返回一个空的 html 文件</li></ol></li><li><ol start="3"><li>客户端初始化时加载必须的js文件，请求接口</li></ol></li><li><ol start="4"><li>将生成的dom插入到html中</li></ol></li></ul><h3 id="缺点-2" tabindex="-1">缺点 <a class="header-anchor" href="#缺点-2" aria-label="Permalink to &quot;缺点&quot;">​</a></h3><ul><li>首屏加载慢</li><li>不利于SEO</li></ul>',21)]))}const b=a(o,[["render",r]]);export{m as __pageData,b as default};
