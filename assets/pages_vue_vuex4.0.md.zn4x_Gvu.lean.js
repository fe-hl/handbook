import{_ as e,c as a,ao as o,o as i}from"./chunks/framework.BbYUXk_8.js";const x=JSON.parse('{"title":"vuex4.0","description":"","frontmatter":{},"headers":[],"relativePath":"pages/vue/vuex4.0.md","filePath":"pages/vue/vuex4.0.md","lastUpdated":1696765695000}'),s={name:"pages/vue/vuex4.0.md"};function l(u,t,c,r,d,n){return i(),a("div",null,t[0]||(t[0]=[o('<h1 id="vuex4-0" tabindex="-1">vuex4.0 <a class="header-anchor" href="#vuex4-0" aria-label="Permalink to &quot;vuex4.0&quot;">​</a></h1><ul><li><a href="https://gitee.com/hl-fe/fe-handbook/tree/master/code/vuex4.0" target="_blank">源码实现地址</a></li></ul><h2 id="vuex" tabindex="-1">Vuex <a class="header-anchor" href="#vuex" aria-label="Permalink to &quot;Vuex&quot;">​</a></h2><ul><li>Vuex 是 Vue.js 中的状态管理工具，提供了一种集中式存储管理应用程序中所有组件的状态的方法。其目的是实现组件之间的状态共享、快速响应数据变化以及对复杂多交互行为进行封装和解耦。</li></ul><h2 id="在-vuex-中-核心概念包括-state、getters、mutations、actions、module-多模块" tabindex="-1">在 Vuex 中，核心概念包括 state、getters、mutations、actions、module(多模块) <a class="header-anchor" href="#在-vuex-中-核心概念包括-state、getters、mutations、actions、module-多模块" aria-label="Permalink to &quot;在 Vuex 中，核心概念包括 state、getters、mutations、actions、module(多模块)&quot;">​</a></h2><ul><li>state:为单一状态树，即将需要管理的多个组件的状态单独抽离出来，生成一个全局的单一状态集合</li><li>getter 为类似于 computed 属性机制，可以监听 state 的变化来返回计算值</li><li>mutations: 为修改状态值的函数，接收的参数为 state 对象</li><li>action: 为异步操作，触发 mutation 来更新状态</li><li>module: 对于大型项目，可以使用 module 将处理功能划分到不同的模块中来维护和管理</li></ul><h2 id="vuex-执行流程" tabindex="-1">vuex 执行流程 <a class="header-anchor" href="#vuex-执行流程" aria-label="Permalink to &quot;vuex 执行流程&quot;">​</a></h2><ul><li>1、当在<code>Vue.use</code>安装<code>Store</code>时，会调用<code>createStore</code>函数，创建<code>Store</code>实例对象，Store内部会通过<code>provide</code>注入一个<code>store</code>实例在根组件上</li><li>2、将外部传递的<code>state</code>,<code>getters</code>,<code>mutations</code>,<code>actions</code>函数进行分类，存储在Store实例中</li><li>3、将格式化后的数据，进行递归模块安装，把所有的 state 状态 挂载到根 state 上，并且通过命名空间将 getter、mutations、action 进行分类，存储在 store 实例上</li><li>4、最后将根 state 的状态通过 reactive 转换成响应式数据</li><li>5、在调用 dispatch、commit 将收集的 mutations、action 统一进行派发</li><li>6、用户在使用的时候，调用vuex提供的<code>useStore</code>函数，内部通过<code>inject</code>去根组件查找<code>Store</code>实例，调用对应的模块</li></ul><h2 id="mutations-为什么不能异步" tabindex="-1">mutations 为什么不能异步 <a class="header-anchor" href="#mutations-为什么不能异步" aria-label="Permalink to &quot;mutations 为什么不能异步&quot;">​</a></h2><ul><li><p>Vuex 中所有的状态更新的唯一途径都是 mutation，异步操作通过 Action 来提交 mutation 实现，这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</p></li><li><p>每个 mutation 执行完成后都会对应到一个新的状态变更，这样 devtools 就可以打个快照存下来，然后就可以实现 time-travel 了。如果 mutation 支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。</p></li></ul><h2 id="actions、mutations-区别" tabindex="-1">actions、mutations 区别 <a class="header-anchor" href="#actions、mutations-区别" aria-label="Permalink to &quot;actions、mutations 区别&quot;">​</a></h2><ul><li>actions中支持异步处理，mutations只能处理同步</li><li>actions中可以提交多个mutations</li></ul><h2 id="为什么要store-commit-xx-才能触发事件执行-而不使用mutation函数进行操作" tabindex="-1">为什么要store.commit(&#39;xx&#39;)才能触发事件执行？而不使用mutation函数进行操作 <a class="header-anchor" href="#为什么要store-commit-xx-才能触发事件执行-而不使用mutation函数进行操作" aria-label="Permalink to &quot;为什么要store.commit(&#39;xx&#39;)才能触发事件执行？而不使用mutation函数进行操作&quot;">​</a></h2><ul><li>在store类中根本没有实现<code>mutation</code>方法，只能通过调用<code>commit</code>方法来执行<code>mutation</code>里的函数列表。</li></ul><h2 id="为什么不可以直接对state存储的状态进行修改-只能通过调用函数的方式修改呢" tabindex="-1">为什么不可以直接对state存储的状态进行修改，只能通过调用函数的方式修改呢？ <a class="header-anchor" href="#为什么不可以直接对state存储的状态进行修改-只能通过调用函数的方式修改呢" aria-label="Permalink to &quot;为什么不可以直接对state存储的状态进行修改，只能通过调用函数的方式修改呢？&quot;">​</a></h2><ul><li>Vuex 通过强制限制对 store 的修改方式来确保状态的可追踪性。只有通过 mutation 函数才能修改 store 中的状态，这样可以轻松地跟踪状态的变化，也可以避免无意中从不同的组件中直接修改 store 导致的代码难以维护和调试的问题。</li></ul><h2 id="为什么存在异步调用的函数需要store-dispatch-xx-中完成呢-而不可以通过store-commit-xx-嘛" tabindex="-1">为什么存在异步调用的函数需要store.dispatch(&#39;xx&#39;)中完成呢？而不可以通过store.commit(&#39;xx&#39;)嘛？ <a class="header-anchor" href="#为什么存在异步调用的函数需要store-dispatch-xx-中完成呢-而不可以通过store-commit-xx-嘛" aria-label="Permalink to &quot;为什么存在异步调用的函数需要store.dispatch(&#39;xx&#39;)中完成呢？而不可以通过store.commit(&#39;xx&#39;)嘛？&quot;">​</a></h2><ul><li>因为在store中，在调用store.commit都是以同步的方式去调用<code>mutations</code>里的函数列表,本身就不支持异步</li><li>在store.dispatch中，是通过<code>Promise.all</code>的方式去调用的<code>actions</code>里的函数列表，支持异步</li></ul>',18)]))}const h=e(s,[["render",l]]);export{x as __pageData,h as default};
